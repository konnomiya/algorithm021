# 周四总结
## BFS (用queue实现)
1. bfs相当于层次遍历，可以计算出从一点到另一点的最短距离。
2. 根据题意也许每一层都要遍历并保存结果，增加一个for loop和变量list保存结果

## DFS (递归 or 栈）
1. dfs其实很多时候是做选择，选 or 不选，选哪一个
2. dfs可能比bfs的时间复杂度要大

## 贪心
1. 贪心每次都取局部最优，试图达到全局最优，无法回退，而动态规划可以回退
2. 如果能证明贪心解法的正确性那么可以使用贪心，否则用动规

## 二分查找（最基本的时间复杂度为logn)
1. 写二分的步骤:
1) 确定搜索区间left 和 right 
2) 确定循环终止条件，left <= right的跳出条件是left > right，left < right的跳出条件是left == right
3）其实确定区间，移动边界的关键点是，根据我们想的算法，边界值是否可能是我们想要的结果，如果不行就移动（+1 or -1）
2. 当输入有序or半有序（具备单调性), 有上下界，可以用索引取值，可以试一试二分

使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方：
感觉就是leetcode 153的变形，找到最小值返回其index即可，可能要处理一下比如如果数组完全有序究竟返回什么。
